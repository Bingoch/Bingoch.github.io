<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2F2019%2F06%2F16%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[1. 三层结构介绍三层架构包括：表现层、业务层、持久层。 1.1 表现层 也就是我们常说的web 层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http 协议请求web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 1.2 业务层 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） 1.3 持久层 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查的。 2. MVC 设计模式MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model（模型） 模型包含业务模型和数据模型，数据模型用于封装数据，业务模型用于处理业务。 View（视图） 通常指的就是我们的 jsp 或者 html，作用一般就是展示数据的。 通常视图是依据模型数据创建的。 Controller（控制器） 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。 3. 执行流程 配置web.xml 配置配置前端控制器DispatcherServlet和拦截的URL 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:mvc="http://www.springframework.org/schema/mvc"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;springmvcTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 1.在servlet-name命名 2.servlet-class就是你对应的拦截器的包，这里默认这样写就好了 3.load-on-startup=1 看名字就知道是指工程运行的的时候就启动该拦截器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 4.servlet-mapping就是设置拦截器将要对哪些请求做出拦截，*.do表示对所有.do的结尾的请求会被拦截处理 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; spring-mvc 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 启用Spring基于annotation的DI, 使用户可以在Spring MVC中使用Spring的强大功能。--&gt; &lt;context:annotation-config /&gt; &lt;!-- DispatcherServlet上下文， 只管理@Controller类型的bean， 忽略其他型的bean, 如@Service --&gt; &lt;context:component-scan base-package="com.springmvc.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- HandlerMapping, 无需配置， Spring MVC可以默认启动。 DefaultAnnotationHandlerMapping annotation-driven HandlerMapping --&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 静态资源处理， css， js， imgs --&gt; &lt;mvc:resources mapping="/resources/**" location="/resources/" /&gt; &lt;!-- 配置视图解析器。 可以用多个ViewResolver。 使用order属性排序。 InternalResourceViewResolver放在最后。 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsps/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;mvc:interceptors&gt; &lt;!-- 使用 bean 定义一个 Interceptor，直接定义在 mvc:interceptors 下面的 Interceptor 将拦截所有的请求 --&gt; &lt;bean class="com.springmvc.interceptor.WrongCodeInterceptor"/&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/demo/hello.do"/&gt; &lt;!-- 定义在 mvc:interceptor 下面的 Interceptor，表示对特定的请求进行拦截 --&gt; &lt;bean class="com.springmvc.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;/beans&gt; Controller返回值及常用注解Controller 方法的返回值分为不使用注解修饰和注解修饰两种。 1. 不使用注解修饰1.1返回ModelAndView12345678@RequestMapping(value = "returnMV")public ModelAndView returnMV() &#123; ModelAndView mv = new ModelAndView(); List&lt;Item&gt; itemList = itemService.findItemList(); mv.addObject("itemList", itemList); mv.setViewName("itemList"); return mv;&#125; 1.2 返回void (1) 使用 request 转发向页面 1request.getRequestDispatcher("页面路径").forward(request, response); (2) 通过 response 页面重定向 1response.sendRedirect("url") (3) 通过 response 指定响应结果 123456@RequestMapping(value = "returnVoid")public void returnVoid(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.setCharacterEncoding("utf-8"); response.setContentType("application/json;charset=utf-8"); response.getWriter().write("findItem2 result");&#125; 1.3 返回字符串 (1) 逻辑视图名 123456@RequestMapping(value = "returnString")public String returnString(Model model) &#123; List&lt;Item&gt; itemList = itemService.findItemList(); model.addAttribute("itemList", itemList); return "itemList";&#125; (2) redirect 重定向 123456789101112131415/** * 返回字符串:redirect重定向 */@RequestMapping(value = "redirectUrl")public String redirectUrl() &#123; System.out.println("代码执行到这里···redirectUrl"); return null;&#125;/** * 测试 */@RequestMapping(value = "test")public String test() &#123; return "redirect:redirectUrl";&#125; (3) forward 转发 123456789101112/** * 返回字符串:forward重定向 */@RequestMapping(value = "forwardUrl")public String forwardUrl() &#123; System.out.println("代码执行到这里···forwardUrl"); return null;&#125;@RequestMapping(value = "test")public String test() &#123; return "forward:forwardUrl";&#125; 2. 使用注解2.1 @ResponseBody 注解@ResponseBody 注解可以通过内置的9种 HttpMessageConverter，匹配不同的 Controller返回值类型，然后进行不同的消息转换处理。 将转换之后的数据放到 HttpServletResponse 对象的响应体返回到页面,不同的 HttpMessageConverter 处理的数据，指定的 ContentType 值也不同。 123456@RequestMapping(value = "returnJson")@ResponseBodypublic List&lt;Item&gt; returnJson(Model model) &#123; List&lt;Item&gt; itemList = itemService.findItemList(); return itemList;&#125; 2.2 @RestController 注解@RestController 注解相当于是 @Controller 和 @ResponseBody 的组合注解，有此注解标注的类，都不需要再写 @ResponseBody 注解了。 123456789101112@RestControllerpublic class RestTestController &#123; @Autowired private ItemService itemService; @RequestMapping(value = "itemList") public List&lt;Item&gt; itemList() &#123; List&lt;Item&gt; itemList = itemService.findItemList(); return itemList; &#125;&#125; 效果和使用 @ResponseBody 注解是完全一样的。 3. @RequestMapping 注解 URL路径映射 @RequestMapping(value=”item”) 或 @RequestMapping(“item”） value的值是数组，可以将多个url映射到同一个方法 @RequestMapping(value = {“itemList”, “items”}) 窄化请求映射 在 class 上添加 @RequestMapping(url) 指定通用请求前缀， 限制此类下的所有方法的访问请求 url 必须以请求前缀开头，通过此方法对 url 进行模块化分类管理。 12345678910111213@RestController@RequestMapping(value = "item")public class RestTestController &#123; @Autowired private ItemService itemService; @RequestMapping(value = &#123;"itemList","items"&#125;) public List&lt;Item&gt; itemList() &#123; List&lt;Item&gt; itemList = itemService.findItemList(); return itemList; &#125;&#125; 请求方法限定 123@RequestMapping(method = RequestMethod.GET)@RequestMapping(method = RequestMethod.POST)@RequestMapping(method=&#123;RequestMethod.GET,RequestMethod.POST&#125;) 参数绑定1. 默认支持的类型SpringMVC 有支持的默认参数类型，我们直接在形参上给出这些默认类型的声明，就能直接使用了。如下： ①、HttpServletRequest 对象 ②、HttpServletResponse 对象 ③、HttpSession 对象 ④、Model/ModelMap 对象 1234567891011121314@RequestMapping("/defaultParameter") public ModelAndView defaultParameter(HttpServletRequest request,HttpServletResponse response,HttpSession session,Model model,ModelMap modelMap) throws Exception&#123; request.setAttribute("requestParameter", "request类型"); response.getWriter().write("response"); session.setAttribute("sessionParameter", "session类型"); //ModelMap是Model接口的一个实现类，作用是将Model数据填充到request域 //即使使用Model接口，其内部绑定还是由ModelMap来实现 model.addAttribute("modelParameter", "model类型"); modelMap.addAttribute("modelMapParameter", "modelMap类型"); ModelAndView mv = new ModelAndView(); mv.setViewName("view/success.jsp"); return mv; &#125; 2. 基本数据类型123456789一、byte，占用一个字节，取值范围为 -128-127，默认是“\u0000”，表示空二、short，占用两个字节，取值范围为 -32768-32767三、int，占用四个字节，-2147483648-2147483647四、long，占用八个字节，对 long 型变量赋值时必须加上&quot;L&quot;或“l”,否则不认为是 long 型五、float，占用四个字节，对 float 型进行赋值的时候必须加上“F”或“f”，如果不加，会产生编译错误，因为系统自动将其定义为 double 型变量。double转换为float类型数据会损失精度。float a = 12.23产生编译错误的，float a = 12是正确的六、double，占用八个字节，对 double 型变量赋值的时候最好加上“D”或“d”，但加不加不是硬性规定七、char,占用两个字节，在定义字符型变量时，要用单引号括起来八、boolean，只有两个值“true”和“false”，默认值为false，不能用0或非0来代替，这点和C语言不同 1234@RequestMapping("/basicData") public void basicData(@RequestParam(value="username") int username)&#123; System.out.println(username); &#125; 问题：我们这里的参数是基本数据类型，如果从前台页面传递的值为 null 或者 “”的话，那么会出现数据转换的异常，就是必须保证表单传递过来的数据不能为null或””，所以，在开发过程中，对可能为空的数据，最好将参数数据类型定义成包装类型 3.包装数据类型包装类型如Integer、Long、Byte、Double、Float、Short，（String 类型在这也是适用的） 1234@RequestMapping("/basicData") public void basicData(@RequestParam(value="username") Integer username)&#123; System.out.println(username); &#125; 4. POJO（实体类）类型的绑定先定义实体类，再进行参数绑定 1234@RequestMapping("/pojo") public void pojo(User user)&#123; System.out.println(user); &#125; 5. 集合类型 数组绑定 1234@RequestMapping("/basicData") public void basicData(@RequestParam(value="ids") int[] ids)&#123; System.out.println(ids); &#125; List与Map绑定 在包装的pojo中新添加一个List 和 Map类型的属性 12345Public class QueryVo &#123; private Map&lt;String, Student&gt; itemInfo; private List&lt;Item&gt; itemList; //get/set方法..&#125; ​]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next搭建博客]]></title>
    <url>%2F2018%2F10%2F12%2FHexo%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[所谓“前人栽树，后人乘凉”，本博客的搭建采用了 Hexo+Next+Github pages ，在搭建过程中参考了众多大佬撰写的教程，在此非常感谢，下面进入正题。 Hexo安装与配置在配置环境之前，我们需要先了解一下Hexo 。 1. 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. Hexo的安装安装 Hexo 之前需要先安装 Node.js 和 Git ，详细安装方法及更多关于 Hexo 内容，详见 Hexo官方文档 。如果你的电脑中已经安装好了，下面就开始进行 Hexo 的安装吧。在D盘（或其他盘）下新建一个hexo目录，开始进行 Hexo 的初始化。 1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog # 新建一个网站$ cd blog$ npm install$ hexo g # 或者hexo generate 生成静态文件$ hexo s # 或者hexo server 启动服务器 初始化以后的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml_config.yml 站点文件是网站的配置信息，可以在此配置大部分的参数。 sourcesource 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。Hexo 会根据主题来生成静态页面。 启动好服务器以后，打开浏览器访问网址： http://localhost:4000/ ，此时可以看到 Hexo 的初始化页面。 3. 添加新的选项这里以”分类“为例，生成“分类”页并添加tpye属性。 1$ hexo new page categories 命令执行完会在\hexo\blog\source\categories 目录下生成一个 index.md 文件，在文件中添加type属性如下： 123title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot; 最终效果如图。如需添加其他选项，步骤类似。 更换主题嫌博客页面太丑，不怕，我们可以安装 Next 主题来定制个性化博客,在站点目录下（/blog）执行如下命令开始安装主题 Next 。 12$ cd /blog$ git clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成以后可以使用如下命令开启服务器本地访问 http://localhost:4000/ 查看页面。 12$ hexo g # 或者hexo generate 生成静态文件$ hexo s # 或者hexo server 启动服务器 关于如何打造更加酷炫的个人博客主页，配置更加个性化的 Next 主题，请参考hexo的next主题个性化教程:打造炫酷网站。 Github Pages设置Hexo 安装好以后，可以在本地生成静态页面，接下来就需要将静态页面远程部署到 gitbub 上，使用Github Pages 默认提供的域名github.io 或者自定义域名来发布站点。Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上。创建Github Pages比较简单，首先需要注册一个github账号，然后再创建一个仓库就行了，仓库名格式必须为：yourusername.github.io，按提示一直下一步即可。关于github的详细配置，可以参考这篇博文git的使用及github的配置。 部署博客到GitHub首先需要安装hexo-deployer-git。 1$ npm install hexo-deployer-git --save 接下来创建一个bash脚本deploy.sh进行自动化部署，每次需要更新博客，执行此脚本即可。 123456hexo g cp -R public/* .deploy/Bingoch.github.io # 这里填写自己的博客仓库名cd .deploy/Bingoch.github.iogit add .git commit -m “update”git push origin master 开始写作博文撰写需要使用 Markdown 语法，Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档。这里推荐一款 Markdown 编辑器 Cmd Markdown，界面非常简洁，可以极大地提高写作效率。以本文为例，格式如下： 12345678910111213---title: 关于本博客的搭建tag: Hexocategories: Hexo---所谓“前人栽树，后人乘凉”，本博客的搭建采用了 **Hexo+Next+Github pages** ，在搭建过程中参考了众多大佬撰写的教程，在此非常感谢，下面进入正题。# 环境配置在配置环境之前，我们需要先了解一下**Hexo** 。## 1. 什么是Hexo**Hexo** 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。... 一篇博文写完之后，保存文件到\hexo\blog\source_posts目录下。接下来生成静态页面，开启服务器本地访问 http://localhost:4000/ 查看页面。如果页面达到预想效果，就可以执行写好的 deploy 脚本将博文部署到github上，此时访问个人博客主页可以看到刚刚发表的文章。 本文至此结束，欢迎评论。再次感谢各位大佬的教程分享。 博客搭建过程，更新于2018-4-16 23:04]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
